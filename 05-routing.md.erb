---
title: Le Routage
slug: routing
date: 0005/01/01
number: 5
contents: Apprende le routage dans Meteor.|Créer des pages pour discuter des posts.|Apprendre à faire des liens vers ces URLs.
paragraphs: 72
---

Maintenant que nous avons une liste de posts (qui peuvent avoir été éventuellement envoyés par des utilisateurs), nous avons besoin d'une page pour chaque post où les utilisateurs auront la possibilité de laisser des commentaires.

Nous aimerions rendre ces pages accessible par un *permalien*, une URL de la forme `http://myapp.com/posts/xyz` (où `xyz` est in iddentifiant MongoDB `_id`) qui est unique pour chaque post.

Cela signifie que nous allons avoir besoin d'un *routage* pour voir ce qu'il y a dans la barre URL du navigateur et afficher le contenu correspondant.

### Ajout du package Iron Router

[Iron Router](https://github.com/EventedMind/iron-router) est un package de routage qui a été créé spécialement pour les applications Meteor.

Non seulement c'est une aide pour le routage (la mise en place des chemins), mais le package s'occupe aussi des filtres (l'assignation de ces chemins à des actions) et il s'occupe même des abonnements (savoir quel chemin permet d'accéder à quelle donnée). (Note: Iron Router a été développer par un des co-auteurs de *Discover Meteor*, Tom Coleman.)

Commençons par installer le package depuis Atmosphere:

~~~bash
$ mrt add iron-router
~~~
<%= caption "Terminal" %>

Cette commande va télécharger et installer le package iron-router dans votre application. Notez que vous devrez probablement redémarrer votre application Meteor (avec `ctrl+c` pour terminer le processus, puis `mrt` pour le redémarrer) avant que le package ne soit utilisable.

Notez que Iron Router est un package tier, ce qui signifie qu'il vous faudra Meteorite pour l'installer (`meteor add iron-router` ne marchera pas).

<% note do %>

### Vocabulaire sur le routage

Nous allons aborder plusieurs fonctionnalitées du routage dans ce chapitre. Si vous avez déjà utilisé un Framework comme Rails vous connaissez probablement la pluspart de ces concepts. Si ce n'est pas la cas, voici un glossaire pour vous aider :

- **Routes** : une route est le bloc de base du routage. C'est un jeu d'instruction qui dit à l'application où aller et quoi faire pour chaque URL.
- **Chemins** : un chemin (ou Path) est une URL de l'application. Elle peut être statique (`/information_legales`) ou dynamique (`/posts/xyz`). Il peut même y avoir des paramètres (`/search?keyword=meteor`).
- **Segments** : ce sont les différentes parties qui composent un chemin, séparées par un slash (`/`).
- **Hooks** : Les Hooks sont les actions qui seront effectuées avant, après ou même pendant le processus de routage. Un exemple typique serait de vérifier si l'utilisateur a les droits nécessaire pour afficher une page.
- **Filtres** : Les filtres sont des hooks qui sont définis globalement pour une ou plusieurs routes.
- **Template de routes** : Chaque route doit pointer vers un template. Si vous n'en précisez pas un, le routeur cherchera le template avec le même nom que la route.
- **Layouts** : On peut voir les layouts comme des cadres photo numérique. Ils contiennent tout le code HTML qui entoure les templates et qui ne bougera pas même si le template est modifié.
- **Controlleurs** : Quelques fois, vous réaliserez que beaucoup de templates réutilisent les mêmes paramètres. Plutôt que de dupliquer votre code, vous pouvez faire hériter toutes ces routes d'un même *controlleur de routage* qui contient toute la logique de routage.

Pour plus d'information sur Iron Router, consultez [la documentation complète sur GitHub](https://github.com/EventedMind/iron-router).

<% end %>

### Routage : Relier des URLS à des templates

Jusqu'à présent nous avons construit notre layout en utilisant des inclusions codées en dur (comme `{{>postsList}}`). Bien que le contenu de notre application puisse changer, la structure de la page est toujours la même : un titre avec une liste de posts en dessous.

Iron Router nous laisse sortir du cadre en nous laissant changer ce qui est affiché dans la balise HTML `<body>`. Donc nous n'allons pas définir le contenu de cette balise nous-même comme dans une page HTML classique. A la place, nous allons pointer le routeur vers un template spécial qui contient un helper de template `{{yield}}`.

Ce helper `{{yield}}` va définir une zone dynamique qui va automatiquement afficher le template correspondant à la route courrante (par convention, nous désignerons à partir de maintenant ces templates spéciaux les "templates de routage") :

<%= diagram "router-diagram", "Layouts and templates.", "pull-center" %>

////

////

~~~html
<head>
  <title>Microscope</title>
</head>
~~~
<%= caption "client/main.html" %>

////

~~~html
<template name="layout">
  <div class="container">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="brand" href="/">Microscope</a>
    </div>
  </header>
  <div id="main" class="row-fluid">
    {{yield}}
  </div>
  </div>
</template>
~~~
<%= caption "client/views/application/layout.html" %>

////

////

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js"%>

////

<% note do %>

### The `/lib` folder

////

////

<% end %>

### Named Routes

////

////

////

////

~~~html
<header class="navbar">
  <div class="navbar-inner">
    <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
  </div>
</header>

//...
~~~
<%= caption "client/views/application/layout.html"%>
<%= highlight "3" %>

<%= commit "5-1", "Very basic routing." %>

### Waiting on Data

////

////

////

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "3,4" %>

////

////

////

////

////

////

~~~html
<template name="loading">
  {{>spinner}}
</template>
~~~
<%= caption "client/views/includes/loading.html" %>

////

<%= commit "5-2", "Wait on the post subscription." %>

<% note do %>

### A First Glance At Reactivity

////

////

////

<% end %>

### Routing To A Specific Post

////

////

////

~~~html
<template name="postPage">
  {{> postItem}}
</template>
~~~
<%= caption "client/views/posts/post_page.html" %>

////

////

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id'
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~6" %>

////

////

////

////

<%= diagram "router-diagram-2", "The data context.", "pull-center" %>

////

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~7" %>

////

////

<% note do %>

### More About Data Contexts

////

////

~~~html
{{#each widgets}}
  {{> widgetItem}}
{{/each}}
~~~

////

~~~html
{{#with myWidget}}
  {{> widgetPage}}
{{/with}}
~~~

////

~~~js
{{> widgetPage myWidget}}
~~~

<% end %>

### Using a Dynamic Named Route Helper

////

////

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html"%>
<%= highlight "6" %>
<%= commit "5-3", "Routing to a single post page." %>

////

////

////

////

////

<%= screenshot "5-2", "A single post page." %>

<% note do %>

### HTML5 pushState

////

////

////

<% end %>
